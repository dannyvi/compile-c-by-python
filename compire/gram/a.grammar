start
  :== stmts

stmts
  :== stmts {{ Nx=get_label() }}  stmt
    | {{ Nx=get_label() }} stmt

stmt
  :== if_else_stmt
    | declare
    | NODE         {{ gen({1}.val) }}

if_else_stmt
  :== if_clause
    | if_clause else_stmt

if_clause
  :== 'if' '('  {{ L1 = get_label() }}
      test ')'
      NODE
      {{ Nx={0}.Nx; L1={3}.L1; tmp = 'if ! '+{4}.true+' goto '+L1;
      }}

else_stmt
  :== 'else'
      {{Nx={0}.Nx;g='goto '+{0}.Nx; l='label '; l1=l+{0}.L1; l2=l+{0}.Nx;
        gen(g,l1, l2)}}
      stmt

test
  :== NUMBER COMP NUMBER   {{ true=' '.join([{1}.val, {2}.val, {3}.val]) }}

declare
  :== declare type ID ';'
      {{ offset = environ.offset();
         environ.update([( {3}.val, Sym({2}.tp, {2}.wth, offset) )])
      }}
         # environ.update({{ {3}.val: Sym({2}.tp, {2}.wth, offset) }})
    | type ID ';'
      {{ offset = environ.offset();
         environ.update([( {2}.val, Sym({1}.tp, {1}.wth, 0) )]);
      }}
         # environ.update({{ {2}.val: Sym({1}.tp, {1}.wth, 0) }});

type
  :== base component                      {{ tp={2}.tp;wth={2}.wth; }}
    | base                                {{ tp={1}.tp;wth={1}.wth }}
    | 'record' '{' {{ global environ; bk=environ; environ=newEnv() }}
      declare '}'
      {{ global environ; wth=environ.offset(); tp=environ;
         environ={3}.bk;
      }}

base
  :== 'int'                               {{ tp='int';wth=4 }}
    | 'float'                             {{ tp='float';wth=8 }}

component
  :== '[' NUMBER ']'             {{ tp={0}.tp;wth=int({2}.val)*{0}.wth }}
    | component '[' NUMBER ']' {{ tp={0}.tp;wth=int({3}.val)*{1}.wth*{0}.wth }}

#assignment_expression
#  :== ID '=' expression ';'
#      {{ ir= {3}.ir + gen(environ.gett({1}.val),'=',{3}.addr) }}

#expression
#  :== expression '+' expression {{  }}
-------------------------------------------------------

import collections
from reprlib import recursive_repr as _recursive_repr

code = ""

class SymTb(collections.OrderedDict):
    """Store symbols in an OrderedDict."""
    def __setitem__(self, key, value):
        if key in self:
            raise KeyError(f"duplicated declarations!! {key} ")
        else:
            collections.OrderedDict.__setitem__(self, key, value)
    def offset(self):
        item = self[next(reversed(self))]
        return item.w+item.f
    @_recursive_repr()
    def __repr__(self):
        'od.__repr__() <==> repr(od)'
        if not self:
            return '%s()' % (self.__class__.__name__,)
        n = self.__class__.__name__
        return '%s(%r)' % (n,
                list(map(lambda x: (x[0],
                ) + x[1] if not x[1].t.__repr__().startswith(n) else
                (x[0],) + ('record', x[1][1], x[1][2]), self.items())))
    def gett(self, key):
        if self.get(key):
            return key
        else:
            raise KeyError('Not declared variable: {key}')


# Sym = collections.namedtuple('Sym', ['name', 'type', 'width', 'offset'])
Sym = collections.namedtuple('S', 't w f', defaults=['',0,0])
newEnv = lambda : SymTb({'': Sym()})

symbol_table = {'global':newEnv()}
environ = symbol_table['global']


all_labels = []

def get_label():
    n = 'L' + str(len(all_labels))
    all_labels.append(n)
    return n



def gen(*args):
    global code
    code += ' '.join(args) + '\n'
